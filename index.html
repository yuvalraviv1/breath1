<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Breath Monitor Prototype</title>
<style>
body { font-family: Arial, sans-serif; margin: 40px; }
#values { margin-top: 20px; font-size: 1.2em; }
#scene-container { width: 100%; height: 400px; }
#debug-canvas { display: block; margin-top: 20px; background: #eee; border: 1px solid #ccc; }
</style>
</head>
<body>
<h1>Breath Monitor Prototype</h1>
<p id="status">Awaiting permission for motion sensors...</p>
<div id="values">
X: <span id="x">0</span><br>
Y: <span id="y">0</span><br>
Z: <span id="z">0</span>
</div>
<div id="scene-container"></div>
<canvas id="debug-canvas" width="300" height="300"></canvas>
<script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
<script>
const SAMPLE_INTERVAL = 250; // milliseconds
const HISTORY_LENGTH = 20;

let scene, camera, renderer;
const spheres = [];
const samples = [];
let lastSampleTime = 0;
let debugCanvas, debugCtx;

function initDebugCanvas() {
    debugCanvas = document.getElementById('debug-canvas');
    if (debugCanvas) {
        debugCtx = debugCanvas.getContext('2d');
    }
}

function zToColor(z) {
    const clamped = Math.max(-10, Math.min(10, z));
    const hue = ((10 - clamped) / 20) * 240; // blue to red
    return `hsl(${hue}, 100%, 50%)`;
}

function drawDot(x, y, z) {
    if (!debugCtx) return;
    const w = debugCanvas.width;
    const h = debugCanvas.height;
    debugCtx.clearRect(0, 0, w, h);
    const px = (x + 10) / 20 * w;
    const py = (y + 10) / 20 * h;
    debugCtx.fillStyle = zToColor(z);
    debugCtx.beginPath();
    debugCtx.arc(px, h - py, 10, 0, Math.PI * 2);
    debugCtx.fill();
}

function initScene() {
    const container = document.getElementById('scene-container');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    for (let i = 0; i < HISTORY_LENGTH; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 16, 16);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.visible = false;
        spheres.push(sphere);
        scene.add(sphere);
    }

    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

function updatePoints() {
    for (let i = 0; i < spheres.length; i++) {
        const sphere = spheres[i];
        if (i < samples.length) {
            const { x, y, z } = samples[i];
            sphere.position.set(x, y, z);
            const t = i / (HISTORY_LENGTH - 1);
            const gray = Math.floor(255 * t);
            sphere.material.color.setRGB(gray / 255, gray / 255, gray / 255);
            sphere.visible = true;
        } else {
            sphere.visible = false;
        }
    }
}
function setupMotion() {
    initScene();
    initDebugCanvas();
    window.addEventListener('devicemotion', event => {
        const { x = 0, y = 0, z = 0 } = event.accelerationIncludingGravity || {};
        document.getElementById('x').textContent = x && x.toFixed ? x.toFixed(2) : '0';
        document.getElementById('y').textContent = y && y.toFixed ? y.toFixed(2) : '0';
        document.getElementById('z').textContent = z && z.toFixed ? z.toFixed(2) : '0';

        const now = Date.now();
        if (now - lastSampleTime >= SAMPLE_INTERVAL) {
            lastSampleTime = now;
            samples.unshift({ x, y, z });
            if (samples.length > HISTORY_LENGTH) {
                samples.pop();
            }
            updatePoints();
        }
        drawDot(x, y, z);
    });
    document.getElementById('status').textContent = 'Reading accelerometer...';
}

function initMotionAccess() {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        // iOS 13+
        DeviceMotionEvent.requestPermission().then(response => {
            if (response === 'granted') {
                setupMotion();
            } else {
                document.getElementById('status').textContent = 'Permission denied.';
            }
        }).catch(err => {
            document.getElementById('status').textContent = 'Permission error: ' + err;
        });
    } else if (typeof DeviceMotionEvent !== 'undefined') {
        // Other browsers that support DeviceMotion without explicit permission
        setupMotion();
    } else {
        document.getElementById('status').textContent = 'DeviceMotion not supported.';
    }
}

document.body.addEventListener('touchstart', initMotionAccess, { once: true });
document.body.addEventListener('click', initMotionAccess, { once: true });
document.getElementById('status').textContent = 'Tap anywhere to allow motion access.';
</script>
</body>
</html>

